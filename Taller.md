# Arquitectura Taller

Presentado por: **Cristian Camilo Gallego**

**1.¿Que es una arquitectura de computadores?**

La arquitectura de computadoras es el diseño conceptual y la estructura operacional fundamental de un sistema de computadoras. Es decir, es un modelo y una descripción funcional de los requerimientos y las implementaciones de diseño para varias partes de una computadora, con especial interés en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede a las direcciones de memoria.

**2.Nombre las generaciones de los computadores y sus características más relevantes.**

***Primera generación (1940-1952)***

Estaban construidas con electrónica de válvulas. Se programaban en lenguaje de la máquina. Un
programa es un conjunto de instrucciones para que la máquina efectue alguna tarea, y el lenguaje más
simple en el que puede especificarse un programa se llama lenguaje de máquina (porque el programa debe
escribirse mediante algún conjunto de códigos binarios). La primera generación de computadoras
1946 ENIAC. Primera computadora digital electrónica en la historia. No fue un modelo de producción,
sino una máquina experimental. Tampoco era programable en el sentido actual.

***Segunda generación (1956-1964)***

La segunda generación de las computadoras reemplazó las válvulas de vacío por los transistores. Por eso,
las computadoras de la segunda generación son más pequeñas y consumen menos electricidad que las de
la anterior. La forma de comunicación con estas nuevas computadoras es mediante lenguajes más
avanzados que el lenguaje de máquina, los cuales reciben el nombre de “lenguajes de alto nivel" o
"lenguajes de programación".
Las características más relevantes de las computadoras de la segunda generación son:
Estaban hechas con la electrónica de transistores. Se programaban con lenguajes de alto nivel 1951 se
inventa la microprogramación, que simplifica mucho el desarrollo de las CPU pero esta
microprogramación también fue cambiada más tarde por el computador alemán Bastian Shuantiger. 1956:
IBM vendió por un valor de 1 230 000 dólares su primer sistema de disco magnético, el RAMAC
(Random Access Method of Accounting and Control). Usaba 50 discos de metal de 61 cm, con 100 pistas
por lado. Podía guardar 5 megabytes de datos, con un coste de 10 000 USD por megabyte.

***Tercera generación (1965-1971)***

Comienza a utilizarse los circuitos integrados, lo cual permitió abaratar costos al mismo tiempo que se
aumentaba la capacidad de procesamiento y se reducía el tamaño de las máquinas. La tercera generación
de computadoras emergió con el desarrollo de circuitos integrados (pastillas de silicio) en las que se
colocan miles de componentes electrónicos en una integración en miniatura. El -8 de la Digital fue el
primer y fue propagado en los comercios. A finales de los años 1950 se produjo la invención del circuito

integrado o chip, por parte de Jack S. Kilby y Robert Noyce. Después llevó a la invención del
microprocesador, en la formación de 1960, investigadores como en el formaban un código, otra forma de
codificar o programar.

***Cuarta generación (1972-1980)***

Fase caracterizada por la integración sobre los componentes electrónicos, lo que propició la aparición del
microprocesador un único circuito integrado en el que se reúnen los elementos básicos de la máquina. Se
desarrolló el "chip".
Se colocan más circuitos dentro de un "chip".Cada "chip" puede hacer diferentes tareas. Un "chip"
sencillo actualmente contiene la unidad de control y la unidad de aritmética/lógica. El tercer componente,
la memoria primaria, es operado por otros "chips".Se reemplaza la memoria de anillos magnéticos por la
memoria de "chips" de silicio. Se desarrollan las microcomputadoras, o sea, computadoras personales o
PC.

***Quinta generación (1983-2017)***

Surge a partir de los avances tecnológicos que se encontraron. Se crea entonces la computadora portátil o
laptop tal cual la conocemos en la actualidad. IBM presenta su primera laptop o computadora portátil y
revoluciona el sector informativo. En vista de la acelerada marcha de la microelectrónica, la sociedad
industrial se ha dado a la tarea de poner también a esa altura el desarrollo del software y los sistemas con
los que se manejaban las computadoras. Estas son la base de las computadoras modernas de hoy en día.
La quinta generación de computadoras, también conocida por sus siglas en inglés, FGCS (de Fifth
Generation Computer Systems) fue un ambicioso proyecto hecho por Japón a finales de la década de los
80. Su objetivo era el desarrollo de una nueva clase de computadoras que utilizarían técnicas y
tecnologías de inteligencia artificial tanto en el plano del hardware como del software,1 usando el
lenguaje PROLOG2 3 4 al nivel del lenguaje de máquina y serían capaces de resolver problemas
complejos, como la traducción automática de una lengua natural a otra


**3.Segun Flynn ¿ Cuál es la clasificación de las arquitecturas?**

Una instrucción, un dato (SISD)
Computador secuencial que no explota el paralelismo en las instrucciones ni en flujos de datos. Es la Arquitectura Von-Neumann. Un único procesador ejecuta un sólo flujo de instrucciones para operar datos en una única memoria. 

Una instrucción, múltiples datos (SIMD)
Todas las unidades ejecutan la misma instrucción sincronizadamente, pero con un datos distinto.

Múltiples instrucciones, un dato (MISD)
Poco común debido al hecho de que la efectividad de los múltiples flujos de instrucciones suele precisar de múltiples flujos de datos. 

Múltiples instrucciones, múltiples datos (MIMD)
Varios procesadores autónomos que ejecutan simultáneamente instrucciones diferentes sobre datos diferentes. 

**4.Nombre las clases de aplicaciones de cómputo.**

***Telecomunicaciones:***

Permite la coordinación de tareas y la gestión competitiva
suministrando una combinación sin precedentes de flexibilidad y eficacia
de las actividades, toma de decisiones coordinadas y ejecución descentralizada, expresión
individualizada y comunicación global.

**Guerra:**

Dentro de este ámbito, la tecnología se aplica en la comunicación
e información. Se utiliza para el diseño y creación de armamento, misiles, etc.
Desgraciadamente la tecnología tiene sus desventajas como 
en este caso, ya que el objetivo es destruir, dañar a personas en 
algunos países, la ventaja viéndolo positivamente sería la 
creación de nuevos armamentos.

***Administración de Empresas:***

Es muy importante dentro de las empresas el utilizar la tecnología, ya que 
facilita el trabajo realizado, toda empresa debe contar con una 
computadora e internet y un software administrativo ya que facilita la 
comunicación y relación con otras personas. También se puede 
almacenar, procesar y difundir información relacionada con dicha empresa, tiene
también su importancia para la capacitación de su personal 
obteniendo mayores beneficios.

***Educación:***

Dentro de este espacio hemos dado un gran paso, ya que con la
tecnología podemos preparar nuestra clase por medio de una
presentación de power point, algún material interactivo, navegación 
de internet. Debido a este avance se han integrado en las escuelas 
aula de medios, utilizando reproducción de videos, presentaciones,
visitas virtuales, etc.


**5.Muestre la clasificación de la jerarquía de un equipo de cómputo.**

Niveles jerárquicos de un equipo de computo.

Nivel 0: Registro

Nivel 1: Memoria caché

Nivel 2: Memoria primaria (RAM)

Nivel 3: Disco duro (con el mecanismo de memoria virtual)

Nivel 4: Cintas magnéticas (consideradas las más lentas, con mayor capacidad, de acceso secuencial)

Nivel 5: Redes (actualmente se considera un nivel más de la jerarquía de memorias)

**6.¿Qué es un compilador?**

Un compilador es un programa especial que procesa las instrucciones escritas en un lenguaje de programación de alto nivel y las convierte a lenguaje de máquina. Un programa que traduce a partir de un lenguaje de bajo nivel a un lenguaje de nivel superior se conoce como descompilador.

Los compiladores son programas muy grandes que permiten la comprobación de errores. Algunos compiladores pueden traducir lenguaje de alto nivel a un lenguaje ensamblador intermedio, que luego se traduce a código de máquina por un programa ensamblador. Otros compiladores generan código de máquina directamente.

**7.¿ Defina qué es una instrucción?**

Una instruccion es accedida por el procesador desde la memoria y son ejecutadas, atrapadas o anuladas, las instrucciones están codificadas en formatos de 3 32 bits y pueden ser particionadas en seis categorías generales.

Las instrucciones SPARC se pueden agrupar en seis categorías: Load/Store, integer Arith-
metic, control Transfer (CTI), registro de control de lectura/escritura, funcionamiento de punto flotante, 
y coprocesador.

**8.¿Cuales son los principios básicos de diseño de hardware de una arquitectura de cómputo, escriba una definición de cada uno?**

	1.La simplicidad favorece la regularidad
	Hacer siempre lo que esta en los parentesis, ir simplificando la operacion
	
	2-Entre más pequeño es más rápido
	Hacer instrucciones mas cortas para que se ejecuten rapido

	3-Hacer el caso común más rápido
	
	4-Buenos diseños demandan grandes compromisos

**9.¿Qué es SPARCV8?**

SPARCV es una arquitectura de conjunto de instrucciones de CPU, derivada de un grupo de instruccion reducida (RISC).
Como arquitectura, SPARC permite un espectro de las implementaciones de chips y sistemas en una variedad de puntos de 
precio/performance para una amplia gama de aplicaciones, incluyendo ciencia/ingeniería, programación, en tiempo real y comercial.

SPARC (Scalable Processor ARChitecture) es una arquitectura RISC big-endian. Es decir, una
arquitectura con un conjunto de instrucciones reducidas.

**10.¿Cuáles son las categorías de instrucciones de la arquitectura SPARCV8?**

Las instrucciones SPARC se pueden agrupar en seis categorías: Load/Store, integer Arith-
metic, control Transfer (CTI), registro de control de lectura/escritura, funcionamiento de punto flotante, 
y coprocesador.



**11.¿Que tipos de registros se encuentran en SPARC V8?**

```
Hay 4 tipos de registros.
Registros de entrada:
in[0]-in[7]             r[24]- r[31]
Registros locales:
local[0]-local[7]       r[16]- r[23]
Registros de salida:
out[0]-out[7]           r[8] - r[15]
Registros Globales:
global[0]-global[7]     r[0] - r[7]
```

**12.¿ Cuál es el número mínimo y máximo de registros que se puede implementar en la arquitectura SPARCV8?**

Una implementación en la arquitectura SPARCV8 tiene como mínimo 40 registros y el máximo 520, dependiendo de la 	implementación. Se dividen en 8 registros globales mas un número de la implementación 16 bits.

**13.¿ Cuáles son las instrucciones de acceso a memoria de SPARCV8? de un ejemplo de cada uno.**

Las instrucciones de memoria son load y store 

Load : Ld[address], rd

Store: St rd, [address]

[address] = rs1 + rs2 ó rs1 + inm

```
Load

h=P[3] + Q[4]     Ld[%L1 + 12], %L3
h=%O0		  Ld[%L2 + 16], %L4
P=%L1		  ADD %L3,%L4,%O0
Q=%L2
```
```
Store

h[4] = P[4] + Q[4] + z	  Ld[%L0 + 16],%L3
h=%O0			  Ld[%L1 + 16],%L4
P=%L0		          ADD %L3,%L4,%L3
Q=%L1			  ADD %L3,%L2,%O0
z=%L2
```
**14. Represente los siguientes números en complemento a 2**
```
a.5

5=  00000000000000000000000000000101
    11111111111111111111111111111010
    +				   1
    ________________________________
-5= 11111111111111111111111111111011
```
```
b.12890

12890=  0000000000000000011001001011010
        1111111111111111100110110100101
        +      			      1
        _______________________________
-12890= 1111111111111111100110110100110    
```
```
c.56900

56900=  00000000000000001101111001000100
	11111111111111110010000110111011
	+                              1
	________________________________
-56900= 11111111111111110010000110111100

```
```
d.11

11=  00000000000000000000000000000001011
     11111111111111111111111111111110100
     +                                 1
     ___________________________________
-11= 11111111111111111111111111111110101
```
```
e.140

140=  00000000000000000000000010001100
      11111111111111111111111101110011
      +                              1
      ________________________________
-140= 11111111111111111111111101110100
```

**15. Explique las instrucciones aritmético lógicas y su sintaxis en lenguaje ensamblador.**

Las instrucciones aritmético logicas que mas usamos son el **ADD**,**SUB**,**AND**,**OR**, pero hay muchas mas

**Syntax ADD**

*ADD rs1, rs2, rd*			
					       
**Syntax SUB**	

*SUB rs1, rs2, rd*

**Syntax AND**

*AND rs1, rs2 ó inm, rd*

**Syntax OR**

*OR rs1, rs2 ó inm, rd*

**16. Explique cada uno de los campos de los 3 formatos de la arquitectura SPARC V8.**

FORMATO  1 Lo utilizan las instrucciones de CALL

|OP |          disp30           |
|---|---------------------------|
		   
FORMATO 2 Lo utilizan las instrucciones Branch,SETHI,COPROCESADOR,FLOAT

|op | rd | op2 | imm22 |         
|---|----|-----|-------|

|op |a| cond | op2 | disp22 |     
|---|-|------|-----|--------|

FORMATO 3 Lo utilizan las instrucciones de memoria, aritmetic-logical , SHIFT, remaining

|op| rd | op3 | rs1 | i=1 | UNSUED| RS2 |
|--|----|-----|-----|-----|-------|-----|

|op| rd | op3 | rs1 | i=0 | simm13 |
|--|----|-----|-----|-----|--------|


**17. ¿Qué diferencia hay entre el campo op, op2 y op3?**

El **OP** me indica que instrucción voy a realizar, ya sea una de memoria, aritmetico logicas, branch etc

El **OP2** me indica que estoy trabajando con el formato 2 con instrucciones de branch, sethi, FBfcc

El **OP3** me indica segun el **OP** que tipo de instruccion u operando estoy realizando, ya sea un ADD, OR, SHIFT,LOAD,STORE


**18. ¿Qué es PSR ?, explique cada uno de sus campos.**

El PSR de 32 bits contiene varios campos que controlan el procesador y mantienen la información de estado. Puede ser modificado por las instrucciones Save, restore, TICC, y rett, y por todas las instrucciones que modifiquen los códigos de condición. Las instrucciones de privilIO RDPSR y WRPSR leen y escriben el PSR directamente.

| impl | ver | icc | reserved | EC | EF |  PIL    | S | PS | ET |  CWP |
|------|-----|-----|----------|----|----|---------|---|----|----|------|

**imp**,**ver**: identificadores de una implementación

**icc**: códigos de condición de la IU. Modificados por las instrucciones enteras cc (por ejemplo ANDcc), y WRPSR

**reserved**: El espacio 14 a 19 son reservados. Cuando es leída por una instrucción RDPSR, este espacio entregan ceros. Para compatibilidad futura, el software supervisor sólo debe emitir instrucciones WRPSR con valores cero en este campo.

**EC**,**EF**: determinan habilitación de los coprocesadores.

**PIL**: identifican el nivel de interrupción de por encima del cual el procesador aceptará una interrupción.

**S**: determina si el procesador está en el modo supervisor o usuario. 1 = modo de supervisor, 0 = modo del usuario.

**PS**: Contiene el valor de S cuando ocurrió el trap más reciente.

**ET**: Un trap pone este bit ET = 0

**CWP**: un contador que identifica la ventana actual en los registros r. El hardware decrementa el CWP en las trampas y guarda las instrucciones, y los incrementa en las instrucciones restore y rett (modulo NWINDOWS).


**19. ¿ Qué es ICC y CWP?**

**ICC**
 :Integer Condition Code, el cual contiene un bit para cada N(negativo), Z(cero), V(overflow), C(carry).
 
**CWP**
  :El Current Window Pointer, CWP, identifica la ventana de registro actual. El CWP es almacenado en los 5 bits menos significativos del registro de estado del procesador, PSR.

**20. ¿Qué es una instrucción sintética, de dos ejemplos?**

Es una forma de ignorar lo obvio en SPARCV8, tenemos dos instrucciones sintéticas utilizadas **MOV** y **CMP**

```
OR %G0, -4, %L0     -->   MOV -4, %L0
SUBcc %L1,4,%G0     -->   CMP %L1, 4
```

**21. ¿Qué significa el campo a para una instrucción BRANCH?.**

Si la instruccion branch tiene el campo 'a' significa que no va a ejecutar el delay instruction

**22. ¿Para qué la instrucción CALL utiliza el registro %O7?.**

La instruccion CALL utiliza el registro %O7 para guardar la dirección de memoria, puesto que las instrucciones de la llamada del procedimiento (CALL y JMPL) no cambian el CWP.

**23.Convertir el siguiente programa en lenguaje de máquina a lenguaje ensamblador y luego a lenguaje de alto nivel:**

 ```a. 10100000000100000010000000000101```
 
 ```OR %g0, 5, %L0```
 
|op |  rd   |  op3   |  rs1  | i |     inm       |
|---|-------|--------|-------|---|---------------|
10 | 10000 | 000010 | 00000 | 1 | 0000000000101  |


```b. 10100010000100000011111111111010```

```OR %g0, -6, %L1```

|op |  rd   |  op3   |  rs1  | i |     inm       |
|---|-------|--------|-------|---|---------------|
|10 | 10001 | 000010 | 00000 | 1 | 1111111111010 |


```c. 10010000000001000100000000010000```

```ADD %L1, %L0, %O0```

|op |  rd   |  op3   |  rs1  | i |  unused |  rs2 |
|---|-------|--------|-------|---|---------|------|
|10 | 01000 | 000000 | 10001 | 0 |00000000 | 10000|


*Lenguaje Alto nivel*

```
int main(){
int a = 5;
int b = -6;
return a+b;
}
```

**24.Solucione el siguiente programas en lenguaje ensamblador, lenguaje de máquina y hexadecimal, además coloque 
su dirección de memoria.**
```                                         
int main(){                                    
        int i = 5;      i=%L0
        int b = -4;     b=%L1
        int c[100];     c=%L2
        int d[20];      d=%L3
        c[5] = i + 2;
        d[4] = b + 3;
        return c[5] + d[4] -i
```
```   
DIR                                   op   rd   op3    rs1  i     inm             HEX
00000   mov 5, %L0                    10|10000|000010|00000|1|0000000000101     A0102005
00004   mov -4, %L1                   10|10001|000010|00000|1|1111111111100     A2103FFC
00008   Ld[%L2 + (100*4)], %L4        11|10100|000000|10010|1|0000110010000     E8046190
0000C   Ld[%L3 + (20*4)], %L5         11|10101|000000|10011|1|0000001010000     EA04E050
00010   add %L0, 2, %L6               10|10110|000000|10000|1|0000000000010     AC042002
00014   St %L6, [%L2 + (5*4)]         11|10110|000100|10010|1|0000000010100     EC24A014
00018   add %L1, 3, %L1               10|10001|000000|10001|1|0000000000011     A2046003
0001C   St %L1,[%L3 + (4*4)]          11|10001|000100|10011|1|0000000010000     E224E010
00020   add %L2, %L3, %L2             10|10010|000000|10010|0|00000000|10011    A4048013
00024   SUB %L2, %L0, %O0             10|01000|000100|10010|0|00000000|10000    90248010
```

**25. Convierta el siguiente código a lenguaje ensamblador, máquina SPARC V8 y hexadecimal.**
```
a.
int main(){                        
int a = 8;              a=%L0      
int b = -14800;         b=%L1      
int c = 33;             c=%L2      
if((a+b)<=b*16){                   
        c=a+(b*2);                 
   }                               
else{                              
   return b-78;                    
}                                   
   return a+c;                     
}     
```

*Lenguaje ensamblador*
```                                          
                                   Lenguaje Maquina
                                   op  rd    op3    rs1  i     inm                HEX
 0000   mov 8,%L0                  10|10000|000010|00000|1|0000000001000        A0102008
 0004   mov -14800,%L1             00|10001|100|1111111111111111110001          233FFFF1
                                   10|10001|000010|10001|0|00000000|10001       A2144011                                     
 0008   mov 33,%L2                 10|10010|000010|00000|1|0000000010001        A4102011
 000C   add %L0,%L1,%L0            10|10000|000000|10000|0|00000000|10001       A0040011 
 0010   SLL %L1,4,%O0              10|01000|100101|10001|1|0000000000100        912C6004
 0014   cmp %L0,%00                10|00000|010100|10000|0|00000000|01000       80A40008
 0018   BG a OPERACION             00|1|1010|010|0000000000000000000010         34800002
 001C   SLL %L1,1,%L1              10|10001|100101|10001|1|0000000000001        A32C6001
 0020   add %L0,%L1,%L2            10|10010|000000|10000|0|00000000|10001       A4040011
        OPERACION 
 0024   SUB %L1,78,%01             10|01001|000100|10001|1|0000001001110        9224604E
        EXIT
 0028   add %L0,%L2,%02            10|01010|000000|10000|0|00000000|10010       94040012
```
```
b.                 
int main(){
   int a = 8;           a=%L0                 
   int b = -10;         b=%L1                 
   if(a!=b){                                  
        return a/16;
   }
   else{
        return b*32;
   }
}
```

*Lenguaje ensamblador*
```                                  Lenguaje Maquina
DIR                                  op  rd    op3    rs1  i      inm                 HEX
0000 mov 8,%L0                       10|10000|000010|00000|1|0000000001000          A0102008  
0004 mov -10,%L1                     10|10000|000010|00000|1|1111111110110          A0103FF6
0008 cmp %L0,%L1                     10|00000|010100|10000|0|00000000|10001         80A40011
000C BE a MULTIPLICAR                00|1|0001|010|0000000000000000000010           22800002
0010 SRL, %L0,4,%O0                  10|01000|100110|10000|1|0000000000100          91342004
     MULTIPLICAR
001C SLL %L1,8,%O0                   10|01000|100101|10001|1|0000000001000          912C6008
     EXIT
```
```
c.
int main(){
   int a = -21180;          a=%L0
}
```
*Lenguaje ensamblador*
```                                 
				    Complemento a 2
                                    00000000000000000101001010111100
                                    11111111111111111010110101000011
                                    +                              1
                                    ________________________________
                                    11111111111111111010110101000100
                                    Primeros 22 bits
                                    1111111111111111101011 = 4194283
                                    Resto de bits 
                                    0101000100 = 324
                                    SETHI                                             HEX
0000 mov -21180,%L0                 00|10000|100|1111111111111111101011             213FFFEB
                                    OR
                                    10|10000|000010|10000|1|0000101000100           A0142144
```
**26.Convierta el siguiente código a lenguaje ensamblador, máquina SPARC V8 y hexadecimal.**
```
int test(int x, int y, int w){          	 
	int z;					                              
	z = x - y + w*4;			      a=%I0                
	return z + 2;				      b=%I1                  
}						      c=%I2                            
						      x=%O0                              
int main(){					      z=%O1
	int a = 4, b = 2, c = -15600;	         	  
	int x = test(a,b,c);			                   
	return x + 45;				                        
}						                                   	  
                                           
```
*Lenguaje ensamblador*
```  
DIR  TEST                       op   rd   op3    rs1  i     inm                   HEX
0000 JMPL %07, 8 ,%G0		10|00000|111000|01000|1|0000000001000	        81C22008
0004 MOV 0,%O1		        10|01001|000010|00000|1|0000101000100	        92102144			
0008 SUB %I0,%I1,%L0            10|10000|000100|11000|0|00000000|11001          A0260019 
000C SLL %I2, 2 ,%L1    	10|10001|100101|11010|1|0000000000010           A32EA002
0010 ADD %L0, %L1, %O1          10|01001|000000|10000|0|00000000|10001          92040011
0014 ADD %O1, 2, %O1	        10|11000|000010|00000|1|0000000000100           B0102004
     MAIN
0018 MOV 4, %I0                 10|11000|000010|00000|1|0000000000100           B0102004

001C MOV -15600,%I2            -15600= 1111111111111111110000 | 1100010000         
                                SETHI  00|11010|100|1111111111111111110000      353FFFF0
                                OR     10|11010|000010|00000|1|0001100010000    34102310     
                                       
0020 CALL TEST                  01|111111111111111111111111111000               7FFFFFF8               
0024 MOV 2, %I1                 10|11001|000010|00000|1|0000000000010           B2102002 
0028 ADD %O0,45,%O0             10|01000|000000|00000|1|0000000|101101          9000202D
```
**27. Implemente la función Pot en lenguaje de alto nivel,lenguaje ensamblador SPARC V8 y lenguaje de máquina SPARC V8 que realice la potencia de dos números enteros sin signo realizando llamados a la función multiplicacion hecha en clase.**

```
#include <stdio.h>                                    

int multiXsumas(int nro1,int nro2){
    int suma = 0; 
    for(int i=1; i<=nro2; i++){
          suma = suma+nro1;        
    }
    return printf("La multiplicacion es: %d",suma);
}

int pot(int base, int exp) {                           
                                                                                                  
int result  =0;                                    
result = multiXsumas(base,exp)                                                    
printf( "El resultado es: %d", result);                      
}    
                                        suma=%O0.           						       
int main () {                           result=%L0              
int base = 3;                   	base=%I0                    
int exp = 3;                    	exp=%I1                    
pot(num1, num2);                        i=%L2                   
}       
```

```
Lenguaje ensamblador		Lenguaje Maquina
DIR     MULTIPLICAR                  
0000    MOV 0, %O0		10|01000|000010|00000|1|0000000000000		90102000
0004    MOV 0,%L2		10|10010|000010|00000|1|0000000000000		A4102000
        FOR
0008    CMP %L2,%I1		10|00000|010100|10010|0|00000000|11001  	80A48019
000C    BGE a ENDFOR		00|1|1011|010|0000000000000000000100		36800004
0010    ADD %O0, %I0, %00	10|01000|000000|01000|0|00000000|01000  	90020008
0014    BA      FOR		00|0|1000|010|0000000000000011111100		108000FC
0018    ADD %L2,1,%L2	        10|10010|000000|10010|1|0000000000001		A404A001
        ENDFOR
001C    JMPL %O7, 8, %G0	10|00000|111000|01111|1|0000000001000		81C3E008
0020    NOP			00|00000|100|0000000000000000000000		1000000
        POT
0024    CALL MULTIPLICAR	01|111111111111111111111111110111     		7FFFFFF7
0028    MOV 0, %L0		10|10000|000010|00000|1|0000000000000		A0102000
        MAIN	
002C    MOV 3,%I0		10|11000|000010|00000|1|0000000000011		B0102003
0030    CALL POT		01|111111111111111111111111111101		7FFFFFFD
0034    MOV 3,%I1		10|11001|000010|00000|1|0000000000011		B2102003
```

28. Implemente una función Fact en lenguaje de alto nivel, lenguaje ensamblador SPARC V8 y lenguaje de máquina SPARC V8 que calcule el factorial de un número entero sin signo.

```
#include <stdio.h>                           
					     
int factorial(int num) {                     
int i=0;                               i=%L0       
int fact=1;                            fact=%O0    
for(i=2;i<=num;i++){                         
   fact=fact*i;                              
}                                             
printf( "El resultado es: %d", fact);                 
}                                                                                       
					     
int main(){                                  
	                                     
    int num=5;               num=%I0         
    factorial(num);                      
}  
```
```
Lenguaje ensamblador
     factorial
0000 MOV 0 %L0			 10|10000|000010|00000|1|0000000000000		A0102000 
0004 MOV 1 %O0  		 10|01000|000010|00000|1|0000000000000   	90102000
IAMFOR
0008 CMP %L0 %I0     		 10|00000|010100|10000|0|00000000|11000		80A40018
000C BGE A ENDFOR   		 00|1|1011|010|0000000000000000000100 		36800004
0010 SLR %O0 %L0 %O0		 10|01000|100101|01000|0|00000000|10000 	912A0010
0014 BA  IAMFOR 		 00|1|1000|010|1111111111111111111100		30BFFFFC   
0018 ADD %L0 1 %L0		 10|10000|000000|10000|0|00000000|00001 	A0040001
 ENDFOR
001C JMPL %07 8 %L0              10|00000|111000|01111|1|0000000001000 		81C3E008
0020 NOP			 00|00000|100|0000000000000000000000		1000000
0024 MOV 5 %I0			 10|11000|000010|00000|1|0000000000101		B0102005
0028 CALL factorial		 01|111111111111111111111111110110 		7FFFFFF6
```
